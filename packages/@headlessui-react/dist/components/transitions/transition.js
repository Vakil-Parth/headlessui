import{Fragment as z,createContext as J,useContext as k,useEffect as x,useMemo as K,useRef as T,useState as G}from"react";import{Features as be,forwardRefWithAs as B,render as Q,RenderStrategy as C}from'../../utils/render.js';import{OpenClosedProvider as Ee,State as w,useOpenClosed as X}from'../../internal/open-closed.js';import{match as P}from'../../utils/match.js';import{useIsMounted as Se}from'../../hooks/use-is-mounted.js';import{useIsoMorphicEffect as Re}from'../../hooks/use-iso-morphic-effect.js';import{useLatestValue as O}from'../../hooks/use-latest-value.js';import{useServerHandoffComplete as Y}from'../../hooks/use-server-handoff-complete.js';import{useSyncRefs as Z}from'../../hooks/use-sync-refs.js';import{useTransition as xe}from'../../hooks/use-transition.js';import{useEvent as H}from'../../hooks/use-event.js';import{useDisposables as Pe}from'../../hooks/use-disposables.js';function S(r=""){return r.split(" ").filter(e=>e.trim().length>1)}let A=J(null);A.displayName="TransitionContext";var He=(s=>(s.Visible="visible",s.Hidden="hidden",s))(He||{});function ye(){let r=k(A);if(r===null)throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");return r}function De(){let r=k(F);if(r===null)throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");return r}let F=J(null);F.displayName="NestingContext";function M(r){return"children"in r?M(r.children):r.current.filter(({el:e})=>e.current!==null).filter(({state:e})=>e==="visible").length>0}function $(r,e){let s=O(r),n=T([]),c=Se(),y=Pe(),g=H((l,i=C.Hidden)=>{let t=n.current.findIndex(({el:o})=>o===l);t!==-1&&(P(i,{[C.Unmount](){n.current.splice(t,1)},[C.Hidden](){n.current[t].state="hidden"}}),y.microTask(()=>{var o;!M(n)&&c.current&&((o=s.current)==null||o.call(s))}))}),b=H(l=>{let i=n.current.find(({el:t})=>t===l);return i?i.state!=="visible"&&(i.state="visible"):n.current.push({el:l,state:"visible"}),()=>g(l,C.Unmount)}),E=T([]),u=T(Promise.resolve()),m=T({enter:[],leave:[],idle:[]}),d=H((l,i,t)=>{E.current.splice(0),e&&(e.chains.current[i]=e.chains.current[i].filter(([o])=>o!==l)),e==null||e.chains.current[i].push([l,new Promise(o=>{E.current.push(o)})]),e==null||e.chains.current[i].push([l,new Promise(o=>{Promise.all(m.current[i].map(([f,a])=>a)).then(()=>o())})]),i==="enter"?u.current=u.current.then(()=>e==null?void 0:e.wait.current).then(()=>t(i)):t(i)}),p=H((l,i,t)=>{Promise.all(m.current[i].splice(0).map(([o,f])=>f)).then(()=>{var o;(o=E.current.shift())==null||o()}).then(()=>t(i))});return K(()=>({children:n,register:b,unregister:g,onStart:d,onStop:p,wait:u,chains:m}),[b,g,n,d,p,m,u])}function Ne(){}let Ve=["beforeEnter","afterEnter","beforeLeave","afterLeave"];function ee(r){var s;let e={};for(let n of Ve)e[n]=(s=r[n])!=null?s:Ne;return e}function Le(r){let e=T(ee(r));return x(()=>{e.current=ee(r)},[r]),e}let we="div",te=be.RenderStrategy,Te=B(function(e,s){let{beforeEnter:n,afterEnter:c,beforeLeave:y,afterLeave:g,enter:b,enterFrom:E,enterTo:u,entered:m,leave:d,leaveFrom:p,leaveTo:l,...i}=e,t=T(null),o=Z(t,s),f=i.unmount?C.Unmount:C.Hidden,{show:a,appear:R,initial:ce}=ye(),[h,I]=G(a?"visible":"hidden"),q=De(),{register:D,unregister:N}=q,_=T(null);x(()=>D(t),[D,t]),x(()=>{if(f===C.Hidden&&!!t.current){if(a&&h!=="visible"){I("visible");return}return P(h,{["hidden"]:()=>N(t),["visible"]:()=>D(t)})}},[h,t,D,N,a,f]);let me=O({enter:S(b),enterFrom:S(E),enterTo:S(u),entered:S(m),leave:S(d),leaveFrom:S(p),leaveTo:S(l)}),V=Le({beforeEnter:n,afterEnter:c,beforeLeave:y,afterLeave:g}),j=Y();x(()=>{if(j&&h==="visible"&&t.current===null)throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?")},[t,h,j]);let U=ce&&!R,pe=(()=>!j||U||_.current===a?"idle":a?"enter":"leave")(),he=H(v=>P(v,{enter:()=>V.current.beforeEnter(),leave:()=>V.current.beforeLeave(),idle:()=>{}})),ve=H(v=>P(v,{enter:()=>V.current.afterEnter(),leave:()=>V.current.afterLeave(),idle:()=>{}})),L=$(()=>{I("hidden"),N(t)},q);xe({container:t,classes:me,direction:pe,onStart:O(v=>{L.onStart(t,v,he)}),onStop:O(v=>{L.onStop(t,v,ve),v==="leave"&&!M(L)&&(I("hidden"),N(t))})}),x(()=>{!U||(f===C.Hidden?_.current=null:_.current=a)},[a,U,h]);let Ce=i,ge={ref:o};return<F.Provider value={L}><Ee value={P(h,{["visible"]:w.Open,["hidden"]:w.Closed})}>{Q({ourProps:ge,theirProps:Ce,defaultTag:we,features:te,visible:h==="visible",name:"Transition.Child"})}</Ee></F.Provider>}),W=B(function(e,s){let{show:n,appear:c=!1,unmount:y,...g}=e,b=T(null),E=Z(b,s);Y();let u=X();if(n===void 0&&u!==null&&(n=P(u,{[w.Open]:!0,[w.Closed]:!1})),![!0,!1].includes(n))throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");let[m,d]=G(n?"visible":"hidden"),p=$(()=>{d("hidden")}),[l,i]=G(!0),t=T([n]);Re(()=>{l!==!1&&t.current[t.current.length-1]!==n&&(t.current.push(n),i(!1))},[t,n]);let o=K(()=>({show:n,appear:c,initial:l}),[n,c,l]);x(()=>{if(n)d("visible");else if(!M(p))d("hidden");else{let a=b.current;if(!a)return;let R=a.getBoundingClientRect();R.x===0&&R.y===0&&R.width===0&&R.height===0&&d("hidden")}},[n,p]);let f={unmount:y};return<F.Provider value={p}><A.Provider value={o}>{Q({ourProps:{...f,as:z,children:<Te ref={E}{...f}{...g}/>},theirProps:{},defaultTag:z,features:te,visible:m==="visible",name:"Transition"})}</A.Provider></F.Provider>}),Oe=B(function(e,s){let n=k(A)!==null,c=X()!==null;return<>{!n&&c?<W ref={s}{...e}/>:<Te ref={s}{...e}/>}</>}),et=Object.assign(W,{Child:Oe,Root:W});export{et as Transition};
